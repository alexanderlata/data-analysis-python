# Продвинутая работа с NumPy

## 1. Генерация случайных чисел

### Задача 1.1 (Базовый уровень)

**Создайте воспроизводимый генератор случайных чисел:**
```python
import numpy as np
rng = np.random.default_rng(seed=42)  # фиксированный seed для воспроизводимости
```

**Выполните следующую генерацию:**
1. Создайте массив из 1000 случайных чисел из равномерного распределения [0, 1) (используйте `rng.uniform(0, 1, 1000)`).
2. Создайте массив из 500 случайных целых чисел от 1 до 100 включительно (используйте `rng.integers(1, 101, 500)`).
3. Сгенерируйте массив из 200 чисел из нормального распределения со средним μ=50 и стандартным отклонением σ=15 (используйте `rng.normal(50, 15, 200)`).
4. Создайте булевый массив размером (10, 10) где True появляется с вероятностью 0.3 (используйте `rng.choice([True, False], size=(10,10), p=[0.3, 0.7])`).
5. Проверьте, что среднее значение нормального распределения близко к 50 (в пределах ±2).
6. Выведите первые 5 элементов каждого массива и результат проверки среднего.

### Задача 1.2 — Выборки и перестановки 

**Дано:** Создайте массив из 20 последовательных целых чисел для демонстрации различных видов выборок:
```python
rng = np.random.default_rng(42)
items = np.arange(20)  # массив [0, 1, 2, ..., 19] для экспериментов с выборками
# Будем демонстрировать различные способы выбора элементов из этого множества
```

**Выполните различные виды выборок:**
1. Создайте случайную перестановку всех элементов - используйте `rng.permutation(items)`.
2. Выберите первые 5 элементов из перестановки.
3. Выполните выборку 5 элементов без возвращения - используйте `rng.choice(items, 5, replace=False)`.
4. Выполните выборку 5 элементов с возвращением - используйте `replace=True`.
5. Перемешайте исходный массив на месте - используйте `rng.shuffle()` (создайте копию).
6. Проверьте, что в выборке без возвращения все элементы уникальны.

### Задача 1.3 (Средний уровень)

**Дано:** Создайте данные об оценках 1000 студентов по 5 предметам с нормальным распределением (среднее=75, стд=12):
```python
rng = np.random.default_rng(42)
students_grades = rng.normal(75, 12, size=(1000, 5))  # 1000 студентов × 5 предметов
students_grades = np.clip(students_grades, 0, 100)    # ограничиваем диапазоном 0-100 баллов
student_names = [f"Студент_{i+1}" for i in range(1000)]
subjects = ['Математика', 'Физика', 'Химия', 'Биология', 'Английский']
```

**Выполните выборки и анализ:**
1. Случайно выберите 100 студентов без повторений для опроса (используйте `rng.choice(1000, 100, replace=False)`).
2. Создайте стратифицированную выборку:
   - Вычислите средний балл каждого студента по всем предметам
   - Выберите по 20 отличников (средний балл > 85), хорошистов (70-85) и троечников (<70)
3. Перемешайте оценки каждого студента по предметам (используйте `rng.shuffle()` с `axis=1` или цикл).
4. Создайте пропуски в данных: замените случайные 5% оценок на NaN (используйте `rng.choice()` для выбора позиций).
5. Создайте 1000 bootstrap-выборок: для каждой выберите 1000 студентов с возвращением и вычислите средний балл выборки.
6. Выведите средний балл исходных данных и 95% доверительный интервал из bootstrap-выборок.


## 2. Статистические функции

### Задача 2.1 — Базовые статистики по осям (basic)

**Дано:** Создайте матрицу случайных чисел размером 6×10 (6 наблюдений × 10 переменных) из стандартного нормального распределения (среднее=0, стандартное отклонение=1):

```python
import numpy as np
rng = np.random.default_rng(42)
X = rng.standard_normal((6, 10))  # 6 строк (наблюдения), 10 столбцов (переменные)
# Значения приблизительно в диапазоне [-3, 3] с центром в 0
```

**Выполните вычисления:**
1. Вычислите среднее для каждой строки (6 значений) - используйте `np.mean()` с `axis=1`.
2. Вычислите среднее для каждого столбца (10 значений) - используйте `axis=0`.
3. Найдите медиану для каждой строки - используйте `np.median()` с `axis=1`.
4. Найдите медиану для каждого столбца - используйте `axis=0`.
5. Вычислите стандартное отклонение для каждой строки - используйте `np.std()` с `axis=1`.
6. Вычислите стандартное отклонение для каждого столбца - используйте `axis=0`.
7. Выведите формы всех результатов для проверки: должны быть `(6,)` для строк и `(10,)` для столбцов.

### Задача 2.2 

**Дано:** Создайте матрицу продаж размером 4×4 (4 месяца × 4 региона) со значениями от 80 до 230 единиц:

```python
import numpy as np
sales = np.array([[120, 150, 80, 200],   # Январь: продажи по 4 регионам
                  [140, 160, 90, 220],   # Февраль: продажи по 4 регионам  
                  [130, 140, 85, 210],   # Март: продажи по 4 регионам
                  [150, 170, 95, 230]])  # Апрель: продажи по 4 регионам
regions = ['Север', 'Юг', 'Восток', 'Запад']
months = ['Янв', 'Фев', 'Мар', 'Апр']
```

**Выполните следующий анализ:**
1. Вычислите средние продажи по каждому региону (столбцу) - используйте `axis=0`.
2. Вычислите средние продажи по каждому месяцу (строке) - используйте `axis=1`.
3. Найдите квартили (25%, 50%, 75%) для каждого региона (используйте `np.percentile()` с `axis=0`).
4. Вычислите коэффициент вариации (стандартное отклонение / среднее) для каждого региона.
5. Определите индекс региона с наименьшим коэффициентом вариации (наименьшая волатильность).
6. Выведите результаты с названиями регионов и месяцев.

### Задача 2.3 — Квантили и межквартильный размах

**Дано:** Создайте матрицу данных размером 1000×5 (1000 наблюдений × 5 признаков) из стандартного нормального распределения:
```python
rng = np.random.default_rng(42)
X = rng.standard_normal((1000, 5))  # большая выборка для стабильных квантилей
# 1000 строк (наблюдения), 5 столбцов (признаки)
# Значения из N(0,1): примерно 95% в диапазоне [-2, 2]
```

**Выполните анализ квантилей:**
1. Вычислите 5-й, 25-й, 50-й, 75-й и 95-й процентили для каждого столбца - используйте `np.percentile()` с `axis=0`.
2. Создайте массив процентилей `percentiles = [5, 25, 50, 75, 95]` и получите результат формы `(5, 5)`.
3. Вычислите межквартильный размах (IQR) для каждого столбца: IQR = 75-й процентиль - 25-й процентиль.
4. Найдите столбец с наибольшим IQR (используйте `np.argmax()`).
5. Выведите процентили в виде таблицы и значения IQR с подписями столбцов.

### Задача 2.4 — Ковариация и корреляция

**Дано:** Создайте матрицу признаков размером 100×4 (100 наблюдений × 4 признака) с искусственной корреляцией:
```python
rng = np.random.default_rng(42)
F = rng.standard_normal((100, 4))  # 100 объектов, 4 независимых признака
# Создадим корреляцию: сделаем второй столбец зависимым от первого
F[:, 1] = 0.7 * F[:, 0] + 0.3 * F[:, 1]  # 70% корреляция с признаком 0
# Теперь F[:,0] и F[:,1] коррелированы, остальные независимы
```

**Выполните корреляционный анализ:**
1. Вычислите ковариационную матрицу между признаками - используйте `np.cov()` с `rowvar=False`.
2. Вычислите корреляционную матрицу - используйте `np.corrcoef()` с `rowvar=False`.
3. Проверьте, что ковариационная матрица симметрична - используйте `np.allclose()`.
4. Извлеките дисперсии признаков из диагонали ковариационной матрицы - используйте `np.diag()`.
5. Найдите пару признаков с наибольшей корреляцией (исключая диагональ) - используйте маскирование.
6. Выведите обе матрицы и индексы наиболее коррелированных признаков.


### Задача 2.5

**Дано:** Создайте временные ряды данных о погоде за 100 дней с взаимосвязанными параметрами:
```python
np.random.seed(42)
days = 100
# Температура: случайное блуждание от базовой температуры 20°C
temperature = 20 + 10 * np.random.randn(days).cumsum() / 10
# Влажность: среднее 60%, стандартное отклонение 20%
humidity = 60 + 20 * np.random.randn(days)
# Атмосферное давление: среднее 1013 гПа, стандартное отклонение 5 гПа
pressure = 1013 + 5 * np.random.randn(days)
# Продажи мороженого: зависят от температуры и влажности + случайный шум
ice_cream_sales = 50 + 2 * temperature + 0.5 * (80 - humidity) + np.random.randn(days) * 5
```

**Выполните корреляционный анализ:**
1. Объедините все данные в одну матрицу размером (100, 4) - температура, влажность, давление, продажи.
2. Вычислите корреляционную матрицу между всеми переменными (используйте `np.corrcoef()` с `rowvar=False`).
3. Найдите ковариационную матрицу (используйте `np.cov()` с `rowvar=False`).
4. Определите, какая переменная имеет наибольшую корреляцию с продажами мороженого (по модулю).
5. Вычислите скользящее среднее продаж с окном в 7 дней (используйте `np.convolve()` или циклы).
6. Найдите дни с аномально высокими продажами - выше 95-го перцентиля (используйте `np.percentile()` и `np.where()`).
7. Выведите количество аномальных дней и их индексы.

## 3. Продвинутая индексация

### Задача 3.1 — Булевая индексация (Базовый уровень)

**Дано:** Создайте массив из 50 случайных целых чисел в диапазоне от 1 до 49 для демонстрации булевой фильтрации:
```python
rng = np.random.default_rng(42)
A = rng.integers(1, 50, size=50)  # 50 случайных целых чисел от 1 до 49
# Примерно 1/3 чисел делится на 3 (16-17 чисел: 3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48)
# Примерно половина четные, половина нечетные
```

**Выполните булевую фильтрацию:**
1. Создайте булеву маску для чисел, которые делятся на 3 - используйте `A % 3 == 0`.
2. Создайте маску для чисел больше 10.
3. Объедините маски с помощью `&`: числа, которые делятся на 3 И больше 10.
4. Извлеките элементы, удовлетворяющие объединенному условию.
5. Подсчитайте количество таких элементов.
6. Замените все четные числа в массиве на их квадраты.
7. Найдите все числа в диапазоне [20, 30] и замените их на -1.
8. Выведите исходный массив, маски и результаты преобразований.

### Задача 3.2 — Логические операторы для массивов (Базовый уровень)

**Дано:** Создайте матрицу размером 100×4 из стандартного нормального распределения:
```python
rng = np.random.default_rng(42)
M = rng.normal(0, 1, size=(100, 4))  # 100 строк × 4 столбца из N(0,1), значения в диапазоне ≈[-3, 3]
```

**Создайте сложные логические условия:**
1. Найдите строки где: (столбец 0 > 0.5 ИЛИ столбец 2 < -0.5) И (столбец 1 > 0).
2. Используйте `np.logical_or()`, `np.logical_and()`, `np.logical_not()`.
3. Создайте условие: хотя бы одно значение в строке > 2.0 - используйте `np.any()` с `axis=1`.
4. Подсчитайте количество строк для каждого условия.
5. Выведите пересечения различных условий.

### Задача 3.3 (Базовый уровень)

**Дано:** Создайте данные о 8 сотрудниках с тремя характеристиками (возраст, зарплата, опыт):
```python
import numpy as np
employees = np.array([
    [25, 50000, 2],    # Сотрудник 0: 25 лет, 50k зарплата, 2 года опыта
    [30, 65000, 5],    # Сотрудник 1: 30 лет, 65k зарплата, 5 лет опыта
    [35, 80000, 8],    # Сотрудник 2: 35 лет, 80k зарплата, 8 лет опыта
    [22, 45000, 1],    # Сотрудник 3: 22 года, 45k зарплата, 1 год опыта
    [40, 95000, 12],   # Сотрудник 4: 40 лет, 95k зарплата, 12 лет опыта
    [28, 58000, 4],    # Сотрудник 5: 28 лет, 58k зарплата, 4 года опыта
    [33, 72000, 7],    # Сотрудник 6: 33 года, 72k зарплата, 7 лет опыта
    [26, 52000, 3]     # Сотрудник 7: 26 лет, 52k зарплата, 3 года опыта
])
# Столбцы: [возраст, зарплата, опыт работы в годах]
```

**Выполните фильтрацию по условиям:**
1. Найдите всех сотрудников старше 30 лет (создайте булеву маску и примените её).
2. Выберите сотрудников с зарплатой от 55000 до 75000 включительно.
3. Найдите молодых высокооплачиваемых: возраст < 30 И зарплата > 60000 (используйте `&`).
4. Найдите опытных сотрудников (опыт >= 5) с низкой зарплатой (< 70000).
5. Создайте маску для "перспективных" сотрудников: молодые (< 32) ИЛИ опытные (>= 7) (используйте `|`).
6. Увеличьте зарплату на 10% только сотрудникам с опытом > 5 лет (модифицируйте исходный массив).
7. Выведите количество сотрудников в каждой категории и обновленную таблицу зарплат.

### Задача 3.4 — Fancy индексация массивами (Средний уровень)

**Дано:** Создайте матрицу размером 200×5 из целых чисел и массив индексов для выборки:
```python
rng = np.random.default_rng(42)
X = rng.integers(1, 100, size=(200, 5))  # 200 строк × 5 столбцов, значения от 1 до 99
indices = np.array([0, 5, 10, 15, 50, 100, 150, 199])  # 8 специфических индексов строк
```

**Выполните выборку по индексам:**
1. Извлеките строки с заданными индексами - используйте `X[indices]`.
2. Измените порядок извлеченных строк на обратный с помощью `indices[::-1]`.
3. Создайте новый массив индексов столбцов `col_indices = [0, 2, 4]`.
4. Извлеките подматрицу строк `indices` и столбцов `col_indices` - используйте `np.ix_()`.
5. Удвойте значения в выбранных строках исходного массива.
6. Создайте случайную перестановку первых 20 строк - используйте `rng.permutation(20)`.
7. Выведите размеры всех промежуточных результатов.

### Задача 3.5 (Средний уровень)

**Дано:** Создайте данные продаж размером 5×5 (5 регионов × 5 товаров) со случайными значениями от 100 до 1000:
```python
regions = ['Север', 'Юг', 'Восток', 'Запад', 'Центр']
products = ['Ноутбук', 'Телефон', 'Планшет', 'Часы', 'Наушники']

rng = np.random.default_rng(42)
sales_matrix = rng.integers(100, 1000, size=(5, 5))  # продажи от 100 до 999 единиц

# Специальные группы для анализа
top_regions_idx = [0, 2, 4]        # Север, Восток, Центр (индексы 0, 2, 4)
premium_products_idx = [0, 1, 3]   # Ноутбук, Телефон, Часы (индексы 0, 1, 3)
seasonal_boost_idx = [1, 2, 4]     # Юг, Восток, Наушники (индексы 1, 2, 4)
```

**Выполните fancy индексацию:**
1. Извлеките продажи только по топ-регионам и премиум-товарам (используйте `np.ix_()`).
2. Найдите максимальные продажи для каждого региона из `top_regions_idx`.
3. Вычислите средние продажи премиум товаров по всем регионам.
4. Примените сезонный буст: увеличьте продажи для позиций из `seasonal_boost_idx` на 20%.
5. Переставьте строки матрицы в порядке [0,4,2,1,3] (используйте fancy индексацию).
6. Создайте новый массив из элементов главной диагонали и антидиагонали.
7. Выведите исходную матрицу, результаты выборок и преобразованную матрицу.

### Задача 3.6 — Fancy индексация массивами (Средний уровень)

**Дано:** Создайте матрицу размером 200×5 из целых чисел и определите индексы для выборки:
```python
rng = np.random.default_rng(42)
X = rng.integers(1, 100, size=(200, 5))  # 200 строк × 5 столбцов, значения 1-99
indices = np.array([0, 5, 10, 15, 50, 100, 150, 199])  # 8 специфических индексов строк
# Выбираем строки: первая, каждая 5-я из первых 20, средняя, предпоследняя четверть, последняя
```

**Выполните выборку по индексам:**
1. Извлеките строки с заданными индексами - используйте `X[indices]`.
2. Измените порядок извлеченных строк на обратный с помощью `indices[::-1]`.
3. Создайте новый массив индексов столбцов `col_indices = [0, 2, 4]`.
4. Извлеките подматрицу строк `indices` и столбцов `col_indices` - используйте `np.ix_()`.
5. Удвойте значения в выбранных строках исходного массива.
6. Создайте случайную перестановку первых 20 строк - используйте `rng.permutation(20)`.
7. Выведите размеры всех промежуточных результатов.

### Задача 3.7 (Продвинутый уровень)

**Дано:** Создайте 3D массив продаж размером 8×6×12 (8 магазинов × 6 товаров × 12 месяцев) со значениями от 50 до 500:
```python
rng = np.random.default_rng(42)
stores, products, months = 8, 6, 12

sales_3d = rng.integers(50, 500, size=(stores, products, months))  # продажи от 50 до 499 единиц
store_names = [f'Магазин_{i+1}' for i in range(stores)]
product_names = ['Электроника', 'Одежда', 'Еда', 'Книги', 'Спорт', 'Красота']
month_names = ['Янв', 'Фев', 'Мар', 'Апр', 'Май', 'Июн',
               'Июл', 'Авг', 'Сен', 'Окт', 'Ноя', 'Дек']
```

**Выполните сложную индексацию:**
1. Найдите топ-3 магазина по общим продажам за год (суммируйте по осям 1 и 2, используйте `np.argsort()`).
2. Определите сезонные товары: продукты где продажи летом (июнь-август, индексы 5-7) больше зимних (декабрь-февраль, индексы 11,0,1).
3. Для каждого магазина найдите его лучший месяц и товар (используйте `np.unravel_index()` с `np.argmax()`).
4. Найдите аномальные продажи: позиции (магазин, товар, месяц) где значения выше 95-го ИЛИ ниже 5-го перцентиля.
5. Разделите магазины по производительности на основе средних месячных продаж:
   - Высокие: > 75-й перцентиль
   - Средние: между 25-м и 75-м
   - Низкие: < 25-й перцентиль
6. Создайте функцию для гибкой выборки:
   ```python
   def extract_sales(store_indices=None, product_indices=None, month_indices=None):
       # Если индексы None, берем все; иначе используем переданные индексы
       # Возвращаем подмассив sales_3d
   ```
7. Протестируйте функцию с разными комбинациями параметров и выведите результаты анализа.

## 4. Функции поиска

### Задача 4.1 — Условный поиск с where (Базовый уровень)

**Дано:** Создайте матрицу размером 8×8 из равномерного распределения [0, 1) для демонстрации условного поиска:
```python
rng = np.random.default_rng(42)
A = rng.uniform(0, 1, size=(8, 8))  # 8×8 матрица со значениями от 0 до 1
# 64 элемента: примерно 50% > 0.5, ~10-15% > 0.8, все ≥ 0
```

**Выполните условный поиск:**
1. Найдите индексы всех элементов больше 0.5 - используйте `np.where(A > 0.5)`.
2. Подсчитайте количество таких элементов.
3. Создайте новый массив: элементы >0.5 замените на 1, остальные на 0 - используйте `np.where()`.
4. Найдите строки, содержащие хотя бы один элемент >0.8.
5. Найдите столбцы, где все элементы <0.7.
6. Используйте `np.where()` для замены отрицательных значений на 0 (сначала добавьте отрицательные).
7. Выведите количество найденных элементов и результаты преобразований.

### Задача 4.2 — Поиск экстремумов (Базовый уровень)

**Дано:** Создайте массивы из стандартного нормального распределения для поиска экстремумов:
```python
rng = np.random.default_rng(42)
v = rng.normal(0, 1, 20)        # 1D массив из 20 элементов N(0,1)
M = rng.normal(0, 1, (5, 6))    # 2D массив 5 строк × 6 столбцов N(0,1)
# Значения в диапазоне примерно [-3, 3], экстремумы вероятно в диапазоне [-2.5, 2.5]
```

**Найдите экстремумы:**
1. Найдите индекс минимального элемента в 1D массиве - используйте `np.argmin()`.
2. Найдите индекс максимального элемента в 1D массиве - используйте `np.argmax()`.
3. Выведите сами значения минимума и максимума по найденным индексам.
4. Для 2D массива найдите индекс глобального минимума - используйте `np.unravel_index()`.
5. Найдите индексы минимумов в каждой строке - используйте `axis=1`.
6. Найдите индексы максимумов в каждом столбце - используйте `axis=0`.
7. Проверьте результаты, выведя сами значения экстремумов.

### Задача 4.3 (Базовый уровень)

**Дано:** Создайте данные о продажах по дням (10 дней, значения от 80 до 300 единиц) и соответствующие названия дней:
```python
import numpy as np
sales = np.array([120, 85, 200, 150, 95, 175, 110, 300, 80, 190])  # 10 дней продаж
days = np.array(['Пн', 'Вт', 'Ср', 'Чт', 'Пт', 'Сб', 'Вс', 'Пн', 'Вт', 'Ср'])  # названия дней
# Значения от 80 до 300 единиц продаж, максимум 300 в индексе 7
```

**Выполните поиск:**
1. Найдите индекс дня с максимальными продажами (используйте `np.argmax()`).
2. Найдите индекс дня с минимальными продажами (используйте `np.argmin()`).
3. Найдите все индексы дней с продажами выше 150 (используйте `np.where()`).
4. Подсчитайте количество дней с продажами ниже среднего значения.
5. Найдите индексы всех понедельников с продажами больше 100.
6. Найдите индексы дней с продажами в диапазоне [100, 200] включительно.
7. Выведите название дня и сумму продаж для максимального и минимального дней.

### Задача 4.4 (Средний уровень)

**Дано:** Создайте матрицу результатов экзаменов размером 50×5 (50 студентов × 5 предметов) с нормальным распределением и 10% пропусков:
```python
rng = np.random.default_rng(42)
# Оценки с нормальным распределением (среднее=75, стд=15), ограничены 0-100
scores = rng.normal(75, 15, size=(50, 5)).astype(int)
scores = np.clip(scores, 0, 100)  # ограничиваем диапазоном 0-100 баллов

# Добавьте 10% пропущенных экзаменов
missing_mask = rng.random((50, 5)) < 0.1  # 10% вероятность пропуска
scores = scores.astype(float)
scores[missing_mask] = np.nan

subjects = ['Математика', 'Физика', 'Химия', 'Биология', 'Английский']
```

**Выполните анализ результатов:**
1. Найдите индекс лучшего студента по каждому предмету, игнорируя NaN (используйте `np.nanargmax()` с `axis=0`).
2. Найдите индекс худшего студента по каждому предмету (используйте `np.nanargmin()` с `axis=0`).
3. Найдите студентов (индексы строк) с максимальным средним баллом по всем предметам.
4. Определите предмет с наибольшим количеством неудач (баллов < 60).
5. Найдите студентов, которые не сдавали ни одного экзамена (все значения в строке = NaN).
6. Найдите "звездных" студентов: тех, кто набрал > 90 баллов минимум по 3 предметам.
7. Используйте `np.unravel_index()` для поиска позиции (строка, столбец) глобального максимума.
8. Выведите результаты с именами предметов и номерами студентов.


### Задача 4.5 — Комплексные условия поиска (Продвинутый уровень)

**Дано:** Создайте матрицу размером 100×3 из стандартного нормального распределения для сложных условий поиска:
```python
rng = np.random.default_rng(42)
X = rng.normal(0, 1, size=(100, 3))  # 100 строк × 3 столбца из N(0,1)
# Столбцы: [переменная_A, переменная_B, переменная_C]
# Значения в диапазоне ≈[-3, 3], медиана каждого столбца ≈ 0
```

**Выполните сложный поиск:**
1. Вычислите медиану первого столбца.
2. Создайте условие: первый столбец > медианы И третий столбец < 0.
3. Найдите индексы строк, удовлетворяющих условию - используйте `np.where()`.
4. Извлеките эти строки из массива.
5. Подсчитайте количество найденных строк и их процент от общего.
6. Найдите строку с максимальной суммой элементов среди найденных.
7. Создайте более сложное условие: |(первый столбец)| > 1 ИЛИ (второй столбец > 1.5 И третий столбец < -0.5).
8. Выведите результаты всех поисков с количественными характеристиками.

### Задача 4.6 (Продвинутый уровень)

**Дано:** Создайте данные о рейтингах фильмов размером 100×20 (100 фильмов × 20 критиков) с нормальным распределением и 15% пропусков:
```python
rng = np.random.default_rng(42)
n_movies, n_critics = 100, 20
# Рейтинги с нормальным распределением (среднее=6.5, стд=1.8), ограничены 1-10
ratings = rng.normal(6.5, 1.8, size=(n_movies, n_critics))
ratings = np.clip(ratings, 1, 10)  # ограничиваем диапазоном 1-10 баллов

# 15% критиков не смотрели случайные фильмы
missing_rate = 0.15
missing_mask = rng.random((n_movies, n_critics)) < missing_rate
ratings[missing_mask] = np.nan
```

**Реализуйте сложные поиски:**
1. Создайте функцию `find_top_movies(k=10)` которая возвращает индексы k фильмов с наивысшим средним рейтингом.
2. Найдите топ-10 фильмов с наибольшим разбросом мнений (высокое стандартное отклонение рейтингов).
3. Найдите "консенсусные" фильмы: с высоким рейтингом (>7.5) И низким разбросом (<1.0).
4. Определите критиков-"пессимистов": тех, чей средний рейтинг ниже общего среднего по всем фильмам.
5. Реализуйте поиск похожих фильмов: для заданного фильма найдите 5 самых похожих по корреляции рейтингов.
6. Найдите "скрытые жемчужины": фильмы с рейтингом >8.0, но количеством оценок <10.
7. Создайте универсальную функцию поиска:
   ```python
   def find_movies(min_rating=7.0, max_variance=1.0, min_reviews=15):
       # Возвращает индексы фильмов, удовлетворяющих всем условиям
   ```
8. Протестируйте все функции и выведите количество найденных фильмов в каждой категории.



## 5. Обработка пропусков и NaN

### Задача 5.1 (Базовый уровень)

**Дано:** Создайте одномерный массив из 10 элементов с 3 пропущенными значениями:
```python
import numpy as np
data = np.array([1.2, 2.5, np.nan, 4.1, 5.3, np.nan, 7.8, 8.2, np.nan, 10.1])
# Массив содержит 7 валидных значений и 3 NaN на позициях 2, 5, 8
```

**Выполните обработку пропусков:**
1. Найдите все позиции NaN значений (используйте `np.isnan()` и `np.where()`).
2. Подсчитайте количество NaN и количество валидных значений (используйте `np.sum()` с булевыми массивами).
3. Вычислите среднее значение, игнорируя NaN (используйте `np.nanmean()`).
4. Найдите медиану без учета NaN (используйте `np.nanmedian()`).
5. Создайте новый массив, заменив все NaN на среднее значение валидных данных.
6. Создайте массив только из валидных значений (отфильтруйте NaN).
7. Выведите исходный массив, позиции NaN, статистики и результаты замены.

### Задача 5.2 — Выявление NaN (Базовый уровень)

**Дано:** Создайте матрицу размером 5×6 из стандартного нормального распределения и добавьте 4 пропуска в заданных позициях:
```python
rng = np.random.default_rng(42)
X = rng.standard_normal((5, 6))  # 5 строк × 6 столбцов из N(0,1)
# Добавим 4 пропуска в определенные позиции для анализа паттернов
X[0, 1] = np.nan  # строка 0, столбец 1
X[1, 3] = np.nan  # строка 1, столбец 3
X[2, 0] = np.nan  # строка 2, столбец 0  
X[4, 5] = np.nan  # строка 4, столбец 5
# Итого: 4 NaN из 30 элементов (13.3% пропусков)
```

**Выполните анализ пропусков:**
1. Найдите общее количество NaN в массиве - используйте `np.isnan()` и `np.sum()`.
2. Подсчитайте количество NaN в каждой строке - используйте `axis=1`.
3. Подсчитайте количество NaN в каждом столбце - используйте `axis=0`.
4. Найдите позиции всех NaN - используйте `np.where(np.isnan(X))`.
5. Создайте булеву маску для NaN значений.
6. Найдите строки, содержащие хотя бы один NaN.
7. Найдите столбцы без NaN.
8. Выведите все результаты с пояснениями.

### Задача 5.3 — Замена NaN медианой по столбцам (Средний уровень)

**Дано:** Создайте матрицу размером 100×4 с нормальным распределением и добавьте 15% случайных пропусков:
```python
rng = np.random.default_rng(42)
X = rng.normal(50, 15, size=(100, 4))  # 100 строк × 4 столбца, μ=50, σ=15
# Значения в диапазоне примерно [5, 95] (μ ± 3σ)
# Добавим 15% случайных пропусков (≈60 пропусков из 400 элементов)
mask = rng.random((100, 4)) < 0.15  # 15% вероятность пропуска для каждого элемента
X[mask] = np.nan
```

**Выполните заполнение пропусков:**
1. Вычислите медиану для каждого столбца, игнорируя NaN - используйте `np.nanmedian()` с `axis=0`.
2. Для каждого столбца создайте булеву маску его NaN значений.
3. Замените NaN в каждом столбце на медиану этого столбца (без циклов по строкам).
4. Проверьте, что в результирующем массиве нет NaN - используйте `np.isnan().any()`.
5. Сравните средние до и после замены для каждого столбца.
6. Вычислите количество замен в каждом столбце.
7. Выведите статистики до и после замены.

### Задача 5.4 — Удаление строк с пропусками (Продвинутый уровень)

**Дано:** Создайте данные размером 200×6 с 10% случайных пропусков и определите ключевые столбцы:
```python
rng = np.random.default_rng(42)
data = rng.normal(0, 1, size=(200, 6))  # 200 строк × 6 столбцов из N(0,1)
# Добавим 10% случайных пропусков (≈120 пропусков из 1200 элементов)
mask = rng.random((200, 6)) < 0.1  # 10% вероятность пропуска
data[mask] = np.nan
key_cols = [0, 2, 4]  # индексы ключевых столбцов: 1-й, 3-й и 5-й столбцы
# Строки с пропусками в ключевых столбцах будут удалены
```

**Выполните фильтрацию строк:**
1. Создайте булеву маску строк с NaN в любом из ключевых столбцов - используйте `np.isnan()`.
2. Инвертируйте маску для получения "чистых" строк - используйте `~`.
3. Отфильтруйте данные, оставив только строки без пропусков в ключевых столбцах.
4. Подсчитайте количество удаленных строк.
5. Вычислите процент оставшихся данных.
6. Проверьте, что в ключевых столбцах результата нет NaN.
7. Сравните размеры исходного и отфильтрованного массивов.
8. Выведите статистику удаления с процентами.

### Задача 5.5 (Продвинутый уровень)

**Дано:** Создайте таблицу погодных данных размером 30×4 (30 дней × 4 параметра) с 15% случайных пропусков:
```python
rng = np.random.default_rng(42)
# 30 дней наблюдений по 4 параметрам погоды
weather_data = rng.normal([20, 65, 1013, 15], [5, 10, 8, 7], size=(30, 4))
# Средние: 20°C, 65% влажность, 1013 гПа давление, 15 км/ч ветер
# Стандартные отклонения: 5, 10, 8, 7 соответственно

# Добавьте 15% случайных пропусков
mask = rng.random((30, 4)) < 0.15  # 15% вероятность пропуска для каждого элемента
weather_data[mask] = np.nan

columns = ['Температура', 'Влажность', 'Давление', 'Скорость_ветра']
```

**Выполните анализ пропусков:**
1. Подсчитайте количество пропусков в каждом столбце.
2. Найдите строки без пропусков - complete cases (используйте `np.isnan()` с `axis=1`).
3. Вычислите среднее, стандартное отклонение и дисперсию по каждому столбцу, игнорируя NaN.
4. Реализуйте forward fill: замените каждый NaN предыдущим валидным значением в том же столбце.
5. Реализуйте простую интерполяцию: замените NaN средним арифметическим между предыдущим и следующим валидными значениями.
6. Вычислите корреляционную матрицу между столбцами для строк без пропусков.
7. Выведите количество пропусков, количество complete cases и результаты заполнения для первых 10 строк.

### Задача 5.6 — Маскированные массивы (Продвинутый уровень)

**Дано:** Создайте данные размером 50×3 с нормальным распределением и добавьте специфические пропуски и выбросы:
```python
rng = np.random.default_rng(42)
data = rng.normal(100, 20, size=(50, 3))  # 50 строк × 3 столбца, μ=100, σ=20
# Значения в нормальном диапазоне [40, 160] (μ ± 3σ)
# Добавим специфические паттерны пропусков и выбросы
data[5:8, 1] = np.nan    # блок NaN: строки 5-7, столбец 1 (3 пропуска)
data[10, :] = np.nan     # полностью пропущенная строка 10 (3 пропуска)  
data[25, 0] = 500        # выброс: значение 500 вместо ≈100 (>6σ от среднего)
# Итого: 6 NaN + 1 выброс из 150 элементов
```

**Работайте с маскированными массивами:**
1. Создайте маскированный массив из данных - используйте `np.ma.masked_invalid()`.
2. Вычислите среднее с помощью `np.ma.mean()` по осям.
3. Создайте дополнительную маску для выбросов (значения > 3 стандартных отклонений).
4. Объедините маски NaN и выбросов - используйте `np.ma.mask_or()`.
5. Примените объединенную маску к данным.
6. Сравните результаты `np.ma.mean()` и `np.nanmean()`.
7. Вычислите количество замаскированных элементов в каждом столбце.

### Задача 5.7 (Продвинутый уровень)

**Дано:** Создайте данные клинических испытаний размером 200×10 (200 пациентов × 10 визитов) где пропуски зависят от состояния здоровья:
```python
rng = np.random.default_rng(42)
n_patients, n_visits = 200, 10

# Базовое состояние здоровья пациентов (среднее=70, стд=15)
baseline_health = rng.normal(70, 15, n_patients)
patient_data = np.zeros((n_patients, n_visits))

# Моделируем ухудшение здоровья и пропуски визитов
for visit in range(n_visits):
    # Здоровье ухудшается на 2 балла за визит + случайные флуктуации
    current_health = baseline_health - visit * 2 + rng.normal(0, 3, n_patients)
    
    # Более больные пациенты чаще пропускают визиты (логистическая модель)
    dropout_prob = 1 / (1 + np.exp((current_health - 50) / 10))
    dropout_mask = rng.random(n_patients) < dropout_prob
    
    patient_data[:, visit] = np.where(dropout_mask, np.nan, current_health)
```

**Выполните продвинутый анализ:**
1. Вычислите процент пропусков на каждом визите и постройте зависимость от номера визита.
2. Найдите пациентов с более чем 50% пропущенных визитов.
3. Реализуйте LOCF (Last Observation Carried Forward): для каждого пациента замените NaN последним доступным значением.
4. Реализуйте простую множественную импутацию: замените NaN средним значением по всем пациентам на том же визите.
5. Сравните три подхода для оценки среднего здоровья на последнем визите:
   - Complete case analysis (только пациенты без пропусков)
   - LOCF
   - Множественная импутация
6. Создайте тепловую карту пропусков: матрицу (пациенты × визиты) где 1 = данные есть, 0 = пропуск.
7. Выведите процент пропусков по визитам, количество пациентов для исключения и сравнение методов.





## 6. Линейная алгебра

### Задача 6.1 — Векторные операции (Базовый уровень)

**Дано:** Создайте два конкретных 3D вектора для демонстрации векторных операций:
```python
import numpy as np
u = np.array([3, 4, 0])   # вектор u: (3, 4, 0)
v = np.array([1, 2, 2])   # вектор v: (1, 2, 2)
```

**Выполните векторные операции:**
1. Вычислите скалярное произведение - используйте `np.dot()`.
2. Найдите нормы (длины) обоих векторов - используйте `np.linalg.norm()`.
3. Найдите векторное произведение a × b (используйте `np.cross()`).
4. Вычислите угол между векторами в радианах: `arccos(u·v / (|u|·|v|))`.
5. Найдите проекцию вектора u на вектор v: `proj = (u·v / |v|²) × v`.
6. Проверьте ортогональность проекции и остатка: `u - proj` должно быть ортогонально v.
7. Нормализуйте оба вектора (приведите к единичной длине).
8. Выведите все результаты с проверками ортогональности.


### Задача 6.2 (Средний уровень)

**Дано:** Система линейных уравнений 3×3 для экономической модели производства товаров:
```
3x + 2y + z = 100   (производство товара A)
x + 4y + 2z = 120   (производство товара B) 
2x + y + 3z = 110   (производство товара C)
```

Создайте матрицы:
```python
import numpy as np
A = np.array([[3, 2, 1],    # Коэффициенты системы уравнений
              [1, 4, 2],
              [2, 1, 3]])
b = np.array([100, 120, 110])  # Правая часть системы
# Ищем решение x = [x, y, z] - количество ресурсов для производства
```

**Выполните решение и анализ:**
1. Решите систему уравнений используя `np.linalg.solve()`.
2. Проверьте решение: вычислите A × x и сравните с b.
3. Вычислите определитель матрицы A (используйте `np.linalg.det()`).
4. Реализуйте метод Крамера для решения данной системы уравнений.
5. Найдите собственные значения и собственные векторы матрицы A (используйте `np.linalg.eig()`).
6. Вычислите обратную матрицу A⁻¹ и проверьте, что A × A⁻¹ = I (используйте `np.linalg.inv()`).
7. Выведите все результаты с пояснениями (комментариями).